# Quark’s Outlines: Emulating Sequence and Mapping Types in Python  
*Overview, Historical Timeline, Problems & Solutions*

## An Overview of Emulating Sequence and Mapping Types in Python

### What does it mean to emulate sequences and mappings in Python?

When you create your own class in Python, you may want it to act like a list or a dictionary. You can do this by emulating the behavior of Python’s built-in sequence and mapping types. This means your object will respond to the same operations as a list or a dict — things like indexing, slicing, or assigning values with square brackets.

To make this work, you define certain special methods. These methods have names like `__getitem__`, `__setitem__`, and `__len__`. Python calls these methods when you use square brackets or when you check the length with `len()`.

**Python lets your objects act like lists or dicts by defining special methods.**

```python
class Box:
    def __init__(self):
        self.data = [10, 20, 30]
    def __getitem__(self, key):
        return self.data[key]

b = Box()
print(b[1])
# prints:
# 20
```

By defining `__getitem__`, this object now works like a list when accessed by index.

### What methods let you emulate Python sequences and mappings?

Python gives you several special methods to control bracket-based access and assignment. These include:

- `__getitem__(self, key)` to read a value
- `__setitem__(self, key, value)` to assign a value
- `__delitem__(self, key)` to delete a value
- `__len__(self)` to return how many items are in the object

If you define these methods in your class, your object will behave like a list (sequence) or a dictionary (mapping), depending on the type of keys it accepts.

**Python lets you create custom containers that work with square brackets.**

```python
class DictLike:
    def __init__(self):
        self.store = {}
    def __setitem__(self, key, value):
        self.store[key] = value
    def __getitem__(self, key):
        return self.store[key]

d = DictLike()
d["color"] = "red"
print(d["color"])
# prints:
# red
```

This object now behaves like a dictionary by using the `__getitem__` and `__setitem__` methods.

---

## A Historical Timeline of Emulating Sequence and Mapping Types in Python  
**Where do Python’s emulation rules come from?**

Python’s design allows custom objects to behave like built-in ones. This behavior comes from early object-oriented design patterns that made behavior depend on method names, not types. Over time, Python gave more control to programmers through special method names.

---

### People built early models for custom containers

**1970s —** **Operator overloading** in languages like C++ allowed classes to define behavior for built-in operators.

**1980 —** **ABC language** used readable syntax for structured data types, which influenced Python.

---

### People designed Python’s special method system

**1991 —** **Python added `__getitem__` and friends** to let user-defined types act like lists or dicts.

**2000 —** **Slicing support extended** with `__getslice__` and other slice helpers.

**2008 —** **Python 3 simplified slicing logic** by standardizing `__getitem__` to accept slice objects.

**2025 —** **Python class interfaces stable** for emulating all standard container behaviors with simple methods.

---

## Problems & Solutions with Emulating Sequences and Mappings in Python  
**How do you use Python’s special methods to build custom containers?**

Python gives you the ability to create your own types that behave like sequences or mappings. These problems show how you can let your objects respond to indexing, length checks, assignments, and deletions by defining special methods.

---

### Problem: How do you return values using square brackets in Python?

You are building a class to store data. You want people to get values using square brackets, like `box[2]`. You do not want them to call a method. You want to use normal Python syntax.

**Problem:** You want to support `obj[key]` syntax in your class.  
**Solution:** Define the `__getitem__` method in your class.

**Python lets you return values with square brackets using `__getitem__`.**

```python
class MyList:
    def __init__(self):
        self.data = ['a', 'b', 'c']
    def __getitem__(self, index):
        return self.data[index]

m = MyList()
print(m[1])
# prints:
# b
```

When Python sees `m[1]`, it calls `m.__getitem__(1)` behind the scenes.

---

### Problem: How do you assign a value using square brackets in Python?

You want your object to work like a dictionary. You want to write `d["key"] = "value"` and have it store the data. You do not want to use a custom method name. You want to use Python’s built-in assignment style.

**Problem:** You want to support `obj[key] = value` syntax.  
**Solution:** Define the `__setitem__` method.

**Python lets you assign values with square brackets using `__setitem__`.**

```python
class MyDict:
    def __init__(self):
        self.data = {}
    def __setitem__(self, key, value):
        self.data[key] = value

d = MyDict()
d["color"] = "blue"
print(d.data)
# prints:
# {'color': 'blue'}
```

Python uses `__setitem__` to store the value when it sees square-bracket assignment.

---

### Problem: How do you delete a value with square brackets in Python?

You made a class that stores values like a list. Now you want users to delete a value by writing `del obj[2]`. You want this to behave like `del mylist[2]`.

**Problem:** You want to support `del obj[key]` syntax.  
**Solution:** Define the `__delitem__` method.

**Python lets you delete values with square brackets using `__delitem__`.**

```python
class MyList:
    def __init__(self):
        self.data = [1, 2, 3]
    def __delitem__(self, index):
        del self.data[index]

m = MyList()
del m[1]
print(m.data)
# prints:
# [1, 3]
```

This method lets your object clean up values using standard Python syntax.

---

### Problem: How do you return the length of a custom container in Python?

You want users to call `len(obj)` and get the number of items. You do not want them to use a custom method like `.size()`. You want to match how Python works with lists and dicts.

**Problem:** You want `len(obj)` to work on your object.  
**Solution:** Define the `__len__` method in your class.

**Python lets you define container length with `__len__`.**

```python
class MyBox:
    def __init__(self):
        self.items = [10, 20, 30]
    def __len__(self):
        return len(self.items)

b = MyBox()
print(len(b))
# prints:
# 3
```

When Python sees `len(b)`, it calls `b.__len__()` behind the scenes.

---

### Problem: How do you support both indexes and keys in Python?

You are building a class that sometimes acts like a list and sometimes like a dict. You want it to support both integer indexes and string keys.

**Problem:** You want flexible key types inside square brackets.  
**Solution:** Handle both inside the `__getitem__` and related methods.

**Python lets you handle keys and indexes in one method.**

```python
class Hybrid:
    def __init__(self):
        self.data = {0: "zero", "one": 1}
    def __getitem__(self, key):
        return self.data[key]

h = Hybrid()
print(h[0])
print(h["one"])
# prints:
# zero
# 1
```

You control which keys are valid. Python passes them straight to your method.

---


## Like, Comment, Share, and Subscribe

Did you find this helpful? Let me know by clicking the like button below. I'd love to hear your thoughts in the comments, too! If you want to see more content like this, don't forget to subscribe. Thanks for reading!

---

[**Mike Vincent**](https://mikevincent.dev) is an American software engineer and app developer from Los Angeles, California. [More about Mike Vincent](https://mikevincent.dev)
