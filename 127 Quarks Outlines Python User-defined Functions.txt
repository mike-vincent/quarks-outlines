# Quark’s Outlines: Python User-Defined Functions  
*Overview, Historical Timeline, Problems & Solutions*

## An Overview of Python User-Defined Functions

### What is a Python user-defined function?

You can define your own function in Python using the `def` keyword. A **Python user-defined function** is made when you write a `def` block in your code. When Python runs this block, it creates a function object.

A function object has special parts. These include its name, its list of default values, and its code. It also keeps a link to the global names from the file where it was made. You can use this object to call the function later with any valid input.

**Python lets you create named function objects with the `def` keyword.**

```python
def greet(name="friend"):
    return "Hello, " + name

print(greet())
print(greet("Mike"))
# prints:
# Hello, friend
# Hello, Mike
```

The function `greet` is now a user-defined function. Python stores its name, code, and default values for later use.

### What are the special parts of a Python function?

A Python function holds many facts about itself. These are called attributes. For example, `__name__` holds the function name. `__defaults__` is a tuple of default values. `__globals__` holds the global names it can see. `__code__` is a special object that stores the function’s bytecode.

**Python functions store their details in special attributes.**

```python
def square(x=2):
    return x * x

print(square.__name__)
print(square.__defaults__)
print(square.__code__.co_varnames)
# prints:
# square
# (2,)
# ('x',)
```

These parts let Python understand and run your function later.

---

## A Historical Timeline of Python User-Defined Functions  
**Where do Python’s user-defined functions come from?**

User-defined functions in Python build on ideas from earlier languages. They let you name blocks of code and reuse them. Over time, Python added new parts to function objects—like closures, default values, and metadata—to make them more powerful.

---

### People designed ways to name and reuse logic

**1958 —** **Functions in LISP** let users define reusable logic blocks for the first time.  
**1972 —** **Procedures in C** gave a fixed way to declare and call code blocks with arguments.  

---

### People added first-class functions to Python

**1991 —** **Python adds `def` keyword**, making user-defined function objects.  
**1994 —** **Python functions gain `__name__` and `__doc__`** attributes.  
**2000 —** **Nested functions and closures added** with lexical scoping in Python 2.1.  
**2004 —** **`__code__` object exposed** to let functions be inspected.  
**2015 —** **Function annotations added** for argument hints and return types.  
**2025 —** **Function structure stable**, with introspection, closures, and metadata all supported.

---

## Problems & Solutions with Python User-Defined Functions  
**How do you use Python user-defined functions the right way?**

Python functions are blocks of code you can name and reuse. These examples show how functions are stored, how their defaults work, how you can inspect them, and how to understand what happens when they are created and called.

---

### Problem: How do you reuse the same logic with different inputs in Python?

You want to avoid repeating the same code. You want to give it a name, reuse it, and pass in different values each time. You need to define a function and call it when needed.

**Problem:** You want to make code reusable and easy to change.  
**Solution:** Python lets you define a function using `def` and call it with arguments.

**Python lets you reuse logic by defining and calling a function.**

```python
def add(x, y):
    return x + y

print(add(2, 3))
print(add(10, -5))
# prints:
# 5
# 5
```

The `add` function gives a simple way to reuse addition logic with any numbers.

---

### Problem: How do you define a function with default values in Python?

You want to make a function that works with or without an input. If no value is given, it should still run using a fallback value. You want a safe default when nothing is passed.

**Problem:** You want a function to work even if no input is given.  
**Solution:** Python lets you set default argument values in your function.

**Python lets you define functions with default argument values.**

```python
def greet(name="friend"):
    return "Hello, " + name

print(greet())
print(greet("Sam"))
# prints:
# Hello, friend
# Hello, Sam
```

The function uses the default value `"friend"` unless another name is given.

---

### Problem: How do you check what a function holds in Python?

You want to look inside a function and see what Python remembers. You want to see its name, its default values, and the code it will run. You want to inspect the function object.

**Problem:** You need to understand what a function knows about itself.  
**Solution:** Python gives function objects special attributes you can inspect.

**Python lets you inspect functions using built-in attributes.**

```python
def square(x=3):
    return x * x

print(square.__name__)
print(square.__defaults__)
print(square.__code__.co_varnames)
# prints:
# square
# (3,)
# ('x',)
```

These attributes show the function name, default values, and variable names.

---

### Problem: How do you store a function for later use in Python?

You want to save a function inside a variable or pass it to another function. You do not want to run it yet. You only want to store the logic until later.

**Problem:** You want to treat functions as values and pass them around.  
**Solution:** Python lets you store function objects in variables or pass them to others.

**Python lets you assign function objects to names and pass them around.**

```python
def shout(word):
    return word.upper() + "!"

s = shout
print(s("hello"))
# prints:
# HELLO!
```

You can treat the `shout` function like any value and use it under another name.

---

### Problem: How do you check a function's global names in Python?

You are inside a function and want to know which global names it can see. You want to inspect where it was defined and what global values it uses. This helps when debugging or writing tools.

**Problem:** You want to trace which global names a function depends on.  
**Solution:** Python stores the global dictionary in the function’s `__globals__`.

**Python lets you inspect the global scope used by a function.**

```python
message = "Hi"

def say():
    return message

print(say.__globals__['message'])
# prints:
# Hi
```

The `__globals__` attribute shows the dictionary of names from the module.

---


## Like, Comment, Share, and Subscribe

Did you find this helpful? Let me know by clicking the like button below. I'd love to hear your thoughts in the comments, too! If you want to see more content like this, don't forget to subscribe. Thanks for reading!

---

[**Mike Vincent**](https://mikevincent.dev) is an American software engineer and app developer from Los Angeles, California. [More about Mike Vincent](https://mikevincent.dev)
